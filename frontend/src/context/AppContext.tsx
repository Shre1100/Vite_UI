import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';

// Define your backend API base URL
// For local development: 'http://localhost:5000'
// For Render deployment: 'https://your-render-app-name.onrender.com'
const BASE_URL = import.meta.env.VITE_BACKEND_URL || 'http://localhost:5000';

// Define a default timeout for API calls (e.g., 10 seconds)
const API_TIMEOUT_MS = 10000; // 10 seconds

export interface User {
  id: string;
  email: string;
  name: string;
  phone?: string;
  role?: string; // 'HR Manager', 'Recruiter', etc.
  hrId?: string; // Specific ID for HR users
  department?: string;
  position?: string;
  roleSet?: boolean; // Indicates if the user has set their role and HR details
}

export interface Candidate {
  id: string;
  name: string; // filename without extension
  matchScore: number;
  matchedSkills: string[];
  department: string; // Department from job requirements
  categorizedField: string; // Category inferred from resume
  shortlisted: boolean; // Frontend state for UI
  rawText?: string; // For viewing resume content
  filepath?: string; // For downloading original file
}

export interface JobRequirement {
  jobId?: string; // ID generated by backend
  userId: string;
  jobDescription: string;
  department: string;
  skills: string[];
  experienceRequired: string; // e.g., "1-3 years", "5+ years", "Any"
}

interface AppContextType {
  // Authentication
  user: User | null;
  setUser: (user: User | null) => void;
  isAuthenticated: boolean;
  setIsAuthenticated: (auth: boolean) => void;
  login: (email: string, password: string) => Promise<{ success: boolean; message: string; user?: User }>;
  register: (email: string, password: string, phone?: string) => Promise<{ success: boolean; message: string; userId?: string }>;
  verifyOtp: (email: string, otp: string, action: 'signup' | 'reset_password') => Promise<{ success: boolean; message: string; user?: User }>;
  forgotPassword: (email: string) => Promise<{ success: boolean; message: string }>;
  resetPassword: (email: string, newPassword: string) => Promise<{ success: boolean; message: string }>;
  selectRole: (userId: string, role: string, fullName: string, hrId?: string, department?: string, position?: string) => Promise<{ success: boolean; message: string }>;
  logout: () => void;

  // Navigation
  currentPage: string;
  setCurrentPage: (page: string) => void;

  // Application State
  currentStep: number;
  setCurrentStep: (step: number) => void;

  // Job Requirements
  jobRequirement: JobRequirement | null;
  setJobRequirement: (job: JobRequirement | null) => void;
  saveJobRequirements: (jobReq: Omit<JobRequirement, 'jobId'>) => Promise<{ success: boolean; jobId?: string; message: string }>;

  // File Management
  uploadedFiles: File[];
  setUploadedFiles: (files: File[]) => void;
  uploadResumes: (files: File[]) => Promise<{ success: boolean; resumeIds?: string[]; message: string }>;

  // Candidates & Screening
  candidates: Candidate[];
  setCandidates: (candidates: Candidate[]) => void;
  filteredCandidates: Candidate[];
  setFilteredCandidates: (candidates: Candidate[]) => void;
  screenResumes: (jobId: string, resumeIds: string[]) => Promise<{ success: boolean; results?: Candidate[]; message: string }>;
  fetchDashboardData: (sortBy?: string) => Promise<{ success: boolean; data?: Candidate[]; message: string }>;

  // Resume Actions
  getResumeRawText: (resumeId: string) => Promise<{ success: boolean; rawText?: string; message: string }>;
  downloadResumeFile: (resumeId: string, filename: string) => Promise<{ success: boolean; message: string }>;
  downloadAllFilteredResumes: (filteredResumeIds: string[]) => Promise<{ success: boolean; message: string }>;

  // UI State
  loading: boolean;
  setLoading: (loading: boolean) => void;
  loadingMessage: string;
  setLoadingMessage: (message: string) => void;

  // Modals
  showModal: string | null;
  setShowModal: (modal: string | null) => void;
  modalData: any;
  setModalData: (data: any) => void;

  // Clear session data
  clearSessionData: () => Promise<void>;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const useApp = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
};

interface AppProviderProps {
  children: ReactNode;
}

export const AppProvider: React.FC<AppProviderProps> = ({ children }) => {
  // Authentication State
  const [user, setUser] = useState<User | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  // Navigation State
  const [currentPage, setCurrentPage] = useState('landing');

  // Application State
  const [currentStep, setCurrentStep] = useState(0);
  const [jobRequirement, setJobRequirement] = useState<JobRequirement | null>(null);
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const [candidates, setCandidates] = useState<Candidate[]>([]);
  const [filteredCandidates, setFilteredCandidates] = useState<Candidate[]>([]);

  // UI State
  const [loading, setLoading] = useState(false);
  const [loadingMessage, setLoadingMessage] = useState('Processing...');
  const [showModal, setShowModal] = useState<string | null>(null);
  const [modalData, setModalData] = useState<any>(null);

  // Load user session on app start
  useEffect(() => {
    const savedUser = localStorage.getItem('epochfolio_user');
    if (savedUser) {
      try {
        const userData: User = JSON.parse(savedUser);
        setUser(userData);
        setIsAuthenticated(true);
      } catch (error) {
        console.error("Failed to parse user data from localStorage:", error);
        localStorage.removeItem('epochfolio_user');
      }
    }
  }, []);

  const login = async (email: string, password: string): Promise<{ success: boolean; message: string; user?: User }> => {
    setLoading(true);
    setLoadingMessage('Signing in...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        const userData: User = {
          id: data.user_id,
          email: data.email,
          name: data.name,
          role: data.role,
          hrId: data.hr_id,
          department: data.department,
          position: data.position,
          roleSet: data.role_set,
        };
        setUser(userData);
        setIsAuthenticated(true);
        localStorage.setItem('epochfolio_user', JSON.stringify(userData));
        return { success: true, message: data.message, user: userData };
      } else {
        return { success: false, message: data.message || 'Login failed' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out. Please try again.' };
      }
      console.error('Login error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const register = async (email: string, password: string, phone?: string): Promise<{ success: boolean; message: string; userId?: string }> => {
    setLoading(true);
    setLoadingMessage('Creating account...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/signup`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password, phone }),
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok || response.status === 200) { // Backend returns 200 if user exists but not verified
        return { success: true, message: data.message, userId: data.user_id };
      } else {
        return { success: false, message: data.message || 'Registration failed' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out. Please try again.' };
      }
      console.error('Registration error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const verifyOtp = async (email: string, otp: string, action: 'signup' | 'reset_password'): Promise<{ success: boolean; message: string; user?: User }> => {
    setLoading(true);
    setLoadingMessage('Verifying OTP...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/verify_otp`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, otp, action }),
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        if (action === 'signup') {
          const userData: User = {
            id: data.user_id,
            email: data.email,
            name: data.name,
            role: data.role,
            hrId: data.hr_id,
            department: data.department,
            position: data.position,
            roleSet: data.role_set,
          };
          setUser(userData);
          setIsAuthenticated(true);
          localStorage.setItem('epochfolio_user', JSON.stringify(userData));
          return { success: true, message: data.message, user: userData };
        } else { // reset_password action
          return { success: true, message: data.message };
        }
      } else {
        return { success: false, message: data.message || 'OTP verification failed' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out. Please try again.' };
      }
      console.error('OTP verification error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const forgotPassword = async (email: string): Promise<{ success: boolean; message: string }> => {
    setLoading(true);
    setLoadingMessage('Sending OTP...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/forgot_password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        return { success: true, message: data.message };
      } else {
        return { success: false, message: data.message || 'Forgot password request failed' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out. Please try again.' };
      }
      console.error('Forgot password error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const resetPassword = async (email: string, newPassword: string): Promise<{ success: boolean; message: string }> => {
    setLoading(true);
    setLoadingMessage('Resetting password...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/reset_password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, new_password: newPassword }),
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        return { success: true, message: data.message };
      } else {
        return { success: false, message: data.message || 'Password reset failed' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out. Please try again.' };
      }
      console.error('Reset password error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const selectRole = async (userId: string, role: string, fullName: string, hrId?: string, department?: string, position?: string): Promise<{ success: boolean; message: string }> => {
    setLoading(true);
    setLoadingMessage('Saving profile...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/select_role`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ user_id: userId, role, full_name: fullName, hr_id: hrId, department, position }),
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        // Update local user state and localStorage after successful role selection
        if (user) {
          const updatedUser = { ...user, role, name: fullName, hrId, department, position, roleSet: true };
          setUser(updatedUser);
          localStorage.setItem('epochfolio_user', JSON.stringify(updatedUser));
        }
        return { success: true, message: data.message };
      } else {
        return { success: false, message: data.message || 'Failed to select role' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out. Please try again.' };
      }
      console.error('Select role error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const logout = async () => {
    setLoading(true);
    setLoadingMessage('Logging out...');
    // No timeout for logout as it's a critical user action and usually quick
    try {
      // Optionally, if you have a backend logout endpoint, call it here
      // await fetch(`${BASE_URL}/api/logout`, { method: 'POST' });

      setUser(null);
      setIsAuthenticated(false);
      setCurrentPage('landing');
      setCurrentStep(0);
      setJobRequirement(null);
      setUploadedFiles([]);
      setCandidates([]);
      setFilteredCandidates([]);
      localStorage.removeItem('epochfolio_user');
      console.log("User logged out and session data cleared.");
    } catch (error) {
      console.error("Logout error:", error);
    } finally {
      setLoading(false);
    }
  };

  const saveJobRequirements = async (jobReq: Omit<JobRequirement, 'jobId'>): Promise<{ success: boolean; jobId?: string; message: string }> => {
    setLoading(true);
    setLoadingMessage('Saving job requirements...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/job_requirements`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: jobReq.userId,
          job_description: jobReq.jobDescription,
          department: jobReq.department,
          skills: jobReq.skills,
          experience_required: jobReq.experienceRequired,
        }),
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        const updatedJobReq = { ...jobReq, jobId: data.job_id };
        setJobRequirement(updatedJobReq);
        return { success: true, jobId: data.job_id, message: data.message };
      } else {
        return { success: false, message: data.message || 'Failed to save job requirements' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out. Please try again.' };
      }
      console.error('Save job requirements error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const uploadResumes = async (files: File[]): Promise<{ success: boolean; resumeIds?: string[]; message: string }> => {
    setLoading(true);
    setLoadingMessage('Uploading and processing resumes...');
    // Resume uploads can take longer, consider a higher timeout if needed
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS * 3); // e.g., 30 seconds for uploads

    try {
      const formData = new FormData();
      files.forEach(file => {
        formData.append('files', file);
      });

      const response = await fetch(`${BASE_URL}/api/upload_resumes`, {
        method: 'POST',
        body: formData,
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        setUploadedFiles(files); // Keep track of original file objects if needed
        return { success: true, resumeIds: data.resume_ids, message: data.message };
      } else {
        return { success: false, message: data.message || 'Failed to upload resumes' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Upload timed out. Please check your connection or try fewer files.' };
      }
      console.error('Upload resumes error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const screenResumes = async (jobId: string, resumeIds: string[]): Promise<{ success: boolean; results?: Candidate[]; message: string }> => {
    setLoading(true);
    setLoadingMessage('Screening resumes...');
    // Screening can be CPU intensive, consider a higher timeout
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS * 5); // e.g., 50 seconds for screening

    try {
      const response = await fetch(`${BASE_URL}/api/screen_resumes`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ job_id: jobId, resume_ids: resumeIds }),
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        const formattedResults: Candidate[] = data.results.map((res: any) => ({
          id: res.resume_id,
          name: res.filename.split('.')[0],
          matchScore: res.match_score,
          matchedSkills: res.matched_skills,
          department: res.department,
          categorizedField: res.categorized_field,
          shortlisted: false, // Default to false
          rawText: res.raw_text, // Include raw text for viewing
          filepath: res.filepath, // Include filepath for downloading
        }));
        setCandidates(formattedResults);
        setFilteredCandidates(formattedResults); // Initially, filtered are all candidates
        return { success: true, results: formattedResults, message: data.message };
      } else {
        return { success: false, message: data.message || 'Failed to screen resumes' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Screening timed out. This might happen with many resumes or complex job descriptions. Please try again.' };
      }
      console.error('Screen resumes error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const fetchDashboardData = async (sortBy: string = 'score'): Promise<{ success: boolean; data?: Candidate[]; message: string }> => {
    setLoading(true);
    setLoadingMessage('Fetching dashboard data...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/dashboard_data?sort_by=${sortBy}`, {
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        // The backend already formats it nicely, just ensure types match
        const formattedData: Candidate[] = data.map((res: any) => ({
          id: res.id,
          name: res.name,
          matchScore: res.matchScore,
          matchedSkills: res.matchedSkills,
          department: res.department,
          categorizedField: res.categorizedField,
          shortlisted: res.shortlisted, // This might be false from backend, frontend manages it
        }));
        setCandidates(formattedData);
        setFilteredCandidates(formattedData);
        return { success: true, data: formattedData, message: 'Dashboard data fetched' };
      } else {
        return { success: false, message: data.message || 'Failed to fetch dashboard data' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out while fetching dashboard data. Please try again.' };
      }
      console.error('Fetch dashboard data error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const getResumeRawText = async (resumeId: string): Promise<{ success: boolean; rawText?: string; message: string }> => {
    setLoading(true);
    setLoadingMessage('Fetching resume text...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/resume_raw_text/${resumeId}`, {
        signal: controller.signal,
      });
      clearTimeout(timeout);
      const data = await response.json();

      if (response.ok) {
        return { success: true, rawText: data.raw_text, message: 'Raw text fetched' };
      } else {
        return { success: false, message: data.message || 'Failed to fetch raw text' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Request timed out while fetching resume text. Please try again.' };
      }
      console.error('Get resume raw text error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const downloadResumeFile = async (resumeId: string, filename: string): Promise<{ success: boolean; message: string }> => {
    setLoading(true);
    setLoadingMessage(`Downloading ${filename}...`);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS * 2); // Slightly longer for file download

    try {
      const response = await fetch(`${BASE_URL}/api/download_resume/${resumeId}`, {
        signal: controller.signal,
      });
      clearTimeout(timeout);

      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
        return { success: true, message: 'Resume downloaded successfully' };
      } else {
        const errorData = await response.json();
        return { success: false, message: errorData.message || 'Failed to download resume' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Download timed out. Please try again.' };
      }
      console.error('Download resume file error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const downloadAllFilteredResumes = async (filteredResumeIds: string[]): Promise<{ success: boolean; message: string }> => {
    setLoading(true);
    setLoadingMessage('Preparing filtered resumes for download...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS * 3); // Longer for zip file generation/download

    try {
      const response = await fetch(`${BASE_URL}/api/download_all_filtered_resumes`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filtered_resume_ids: filteredResumeIds }),
        signal: controller.signal,
      });
      clearTimeout(timeout);

      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'filtered_resumes.zip';
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
        return { success: true, message: 'Filtered resumes downloaded successfully' };
      } else {
        const errorData = await response.json();
        return { success: false, message: errorData.message || 'Failed to download filtered resumes' };
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return { success: false, message: 'Download timed out. Please try again.' };
      }
      console.error('Download all filtered resumes error:', error);
      return { success: false, message: 'Network error or server unreachable' };
    } finally {
      setLoading(false);
    }
  };

  const clearSessionData = async () => {
    setLoading(true);
    setLoadingMessage('Clearing session data...');
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    try {
      const response = await fetch(`${BASE_URL}/api/clear_session_data`, {
        method: 'POST',
        signal: controller.signal,
      });
      clearTimeout(timeout);

      if (response.ok) {
        setJobRequirement(null);
        setUploadedFiles([]);
        setCandidates([]);
        setFilteredCandidates([]);
        setCurrentStep(0);
        console.log("Frontend session data cleared.");
        return; // No specific return value needed for success
      } else {
        const errorData = await response.json();
        console.error("Failed to clear backend session data:", errorData.message);
        // Optionally, return a message to the UI
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        console.error('Clear session data timed out.');
      } else {
        console.error("Error clearing session data:", error);
      }
    } finally {
      setLoading(false);
    }
  };


  const value: AppContextType = {
    // Authentication
    user,
    setUser,
    isAuthenticated,
    setIsAuthenticated,
    login,
    register,
    verifyOtp,
    forgotPassword,
    resetPassword,
    selectRole,
    logout,

    // Navigation
    currentPage,
    setCurrentPage,

    // Application State
    currentStep,
    setCurrentStep,

    // Job Requirements
    jobRequirement,
    setJobRequirement,
    saveJobRequirements,

    // File Management
    uploadedFiles,
    setUploadedFiles,
    uploadResumes,

    // Candidates & Screening
    candidates,
    setCandidates,
    filteredCandidates,
    setFilteredCandidates,
    screenResumes,
    fetchDashboardData,

    // Resume Actions
    getResumeRawText,
    downloadResumeFile,
    downloadAllFilteredResumes,

    // UI State
    loading,
    setLoading,
    loadingMessage,
    setLoadingMessage,

    // Modals
    showModal,
    setShowModal,
    modalData,
    setModalData,

    // Clear session data
    clearSessionData,
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
};
